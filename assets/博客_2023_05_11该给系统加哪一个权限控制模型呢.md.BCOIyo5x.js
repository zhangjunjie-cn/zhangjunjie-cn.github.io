import{_ as s}from"./chunks/WDocTitleMeta.BAjFFfAr.js";import{_ as h,C as c,c as A,o as r,j as o,G as p,aU as d,a as u,w as C,b as B,e as b}from"./chunks/framework.BAt86-JR.js";import"./chunks/theme.BnlwNlXQ.js";const x=JSON.parse('{"title":"哪一个权限控制模型呢？(DAC|MAC|RBAC|RuBAC|ABAC)","description":"","frontmatter":{},"headers":[],"relativePath":"博客/2023/05/11该给系统加哪一个权限控制模型呢.md","filePath":"博客/2023/05/11该给系统加哪一个权限控制模型呢.md","lastUpdated":1760196138000}'),E={name:"博客/2023/05/11该给系统加哪一个权限控制模型呢.md"};function m(e,a,g,R,f,_){const i=s,n=c("ClientOnly");return r(),A("div",null,[a[0]||(a[0]=o("h1",{id:"哪一个权限控制模型呢-dac-mac-rbac-rubac-abac",tabindex:"-1"},[u("哪一个权限控制模型呢？(DAC|MAC|RBAC|RuBAC|ABAC) "),o("a",{class:"header-anchor",href:"#哪一个权限控制模型呢-dac-mac-rbac-rubac-abac","aria-label":'Permalink to "哪一个权限控制模型呢？(DAC|MAC|RBAC|RuBAC|ABAC)"'},"​")],-1)),p(n,null,{default:C(()=>{var l,t;return[(((l=e.$frontmatter)==null?void 0:l.aside)??!0)&&(((t=e.$frontmatter)==null?void 0:t.showWDocTitleMeta)??!0)?(r(),B(i,{key:0,article:e.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),a[1]||(a[1]=d('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>最近想给<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2023/05/07%E4%B8%A4%E4%B8%AA%E5%A4%9A%E6%9C%88%E6%8D%A3%E9%BC%93%E4%BA%86%E4%B8%80%E4%B8%AA%E5%81%A5%E5%BA%B7%E7%B1%BB%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" target="_blank" rel="noreferrer">自己的小程序</a>的GPT调用接口增加一个权限控制，比如可以是这类策略：普通用户智能免费调用10次该接口，然后用户可以购买VIP会员，然后就可以无限次调用该接口。</p><p>社区中听得最多的权限控制模型就是RBAC，比如<a href="https://docs.nestjs.com/security/authorization#basic-rbac-implementation" target="_blank" rel="noreferrer">Nest的官方文档</a>中介绍权限控制的章节就是以该模型为例。</p><p>但是我就一定要选择这种方案吗？这种方案对于我现在的实际业务情况是最佳选择吗？所以，下面我们来详细聊聊常见的几种权限模型，再来根据实际情况谈谈设计方案。</p><h2 id="自主访问控制-dac" tabindex="-1">自主访问控制（DAC） <a class="header-anchor" href="#自主访问控制-dac" aria-label="Permalink to &quot;自主访问控制（DAC）&quot;">​</a></h2><h3 id="基本介绍" tabindex="-1">基本介绍 <a class="header-anchor" href="#基本介绍" aria-label="Permalink to &quot;基本介绍&quot;">​</a></h3><p><strong>自主</strong>访问控制模型（Discretionary Access Control，DAC）是一种基于主体（如用户、进程）和客体（如文件、目录、资产）之间关系来控制访问的权限控制模型。在DAC中，主体可以自主控制访问对象的权限，即<strong>主体拥有对对象的完全控制权</strong>，可以自由授权和收回对对象的访问权限。</p><p>重点就在于一个自主，即主体拥有对对象的完全控制权</p><p>DAC模型的优点是简单易于实现，适用于权限控制较为简单的场景，资源的权限可以非常灵活的进行传播。</p><p>说是灵活，但也可以说是随意。它也有缺点，例如权限分散，难以管理；安全性较低，容易受到攻击等。</p><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><p>举几个生活中的例子来帮助大家理解：</p><ol><li>社交媒体：在社交媒体平台中，用户可以设置自己的个人资料和隐私权限，例如是否公开自己的名字、头像和个人信息等。再详细一点，比如朋友圈，朋友圈就是每个用户自己拥有的资源，而是否公开，向哪些人公开，公开哪几条朋友圈都是由用户自己说了算。</li><li>手机热点：手机热点也是用户自己拥有的资源，用户可以随意更改哪些用户可以访问我的热点，最多几人访问我的人热点等等。</li><li>移动设备：在移动设备中，整个移动设备属于用户自己拥有的资源。用户可以设置各种应用程序的权限，例如访问设备存储、网络、电话、短信等权限。用户可以根据需要给予或收回应用程序的权限。</li></ol><p><img src="https://oss.justin3go.com/blogs/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8BDAC%E7%9A%84%E6%8F%8F%E8%BF%B0.png" alt="" loading="lazy"></p><p>上面举的几个例子都是DAC比较适用的例子，因为上层管理员不会有统一或者分组管理相应资源的场景。但是比如出现该场景：比如重庆市所有人三个月前发的朋友圈不能共享，如果真要来实现这个功能，可能并不太好操作，这也是DAC权限过于分散的缺点体现。</p><p>来，我们一起来类比理解一下（当然，没有下面的相关经验也可以直接跳过）：</p><ul><li>其实就有点区块链去中心化的那种感觉，所以这也是为什么对于这方面监管这么严格的原因，太乱了，不好管理。</li><li>也好比<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2023/02/19%E6%94%BE%E5%BC%83Cookie-Session%EF%BC%8C%E6%8B%A5%E6%8A%B1JWT%EF%BC%9F.html" target="_blank" rel="noreferrer">JWT</a>将登录控制分发出去，凭证由用户自己控制，那强制下线就很难做，只能额外增加一层黑名单控制逻辑。</li></ul><h2 id="强制访问控制-mac" tabindex="-1">强制访问控制（MAC） <a class="header-anchor" href="#强制访问控制-mac" aria-label="Permalink to &quot;强制访问控制（MAC）&quot;">​</a></h2><h3 id="基本介绍-1" tabindex="-1">基本介绍 <a class="header-anchor" href="#基本介绍-1" aria-label="Permalink to &quot;基本介绍&quot;">​</a></h3><p>还是其实从名字上就能理解，DAC是自主，MAC是强制。</p><p>这种强制就体现在：在MAC模型里，授权不是由每个用户来掌控的。相反，<strong>授权的决定是由系统管理员来定制的</strong>。这样，管理员可以更好地控制用户的访问权限。同时，也有效地避免了用户通过其他手段来绕过访问控制系统的限制，确保了系统的强制性。</p><p><img src="https://oss.justin3go.com/blogs/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8BMAC%E7%9A%84%E6%8F%8F%E8%BF%B0.png" alt="" loading="lazy"></p><h3 id="例子-1" tabindex="-1">例子 <a class="header-anchor" href="#例子-1" aria-label="Permalink to &quot;例子&quot;">​</a></h3><p>我们再来举几个生活的例子帮助大家理解</p><ul><li>护照：如果您想要访问某些国家，您需要先获得批准并获得护照。利用这种方式，国家可以通过MAC模型，为不同的人员授予不同的访问权限。</li><li>校园卡：学校使用MAC模型，针对不同的学生身份，赋予其进入对应寝室楼的权利，不是该寝室楼的（没有该权限的）不能进入该寝室。</li></ul><p>这样系统管理员就需要记录每位用户拥有哪些权限，太细了，上面的例子同样也是比较适合MAC模型的例子，因为只有一种权限，就是是否能进出；</p><p>但是在其他场景中，比如员工系统中，用户升职了，就得专门为这个用户增加几条对应职位的权限，不同的用户可能对应有几十上百条权限需要管理，我们的安全管理员又要跑路了。</p><h2 id="基于角色的访问控制-rbac" tabindex="-1">基于角色的访问控制（RBAC） <a class="header-anchor" href="#基于角色的访问控制-rbac" aria-label="Permalink to &quot;基于角色的访问控制（RBAC）&quot;">​</a></h2><h3 id="基本介绍-2" tabindex="-1">基本介绍 <a class="header-anchor" href="#基本介绍-2" aria-label="Permalink to &quot;基本介绍&quot;">​</a></h3><p>上面两个模型似乎都太过于极端，一个极端的自由，一个极端的约束。所以，程序员经典的一句话就是“遇事不决，再加一层”。增加一层适配解耦呗，RBAC的关键就是在MAC的基础上，主体与资源操作权限中增加了一层角色进行权限控制。</p><p>这样系统管理员，或者说是安全员要管理的逻辑就轻松多了。不同对每位用户细分到每一条具体的权限，只需要分配一个角色（权限组）就可以了。</p><p>RBAC是如今非常流行的一种权限控制模型，因此也分为了0-3四种。</p><h3 id="rbac0" tabindex="-1">RBAC0 <a class="header-anchor" href="#rbac0" aria-label="Permalink to &quot;RBAC0&quot;">​</a></h3><p><img src="https://oss.justin3go.com/blogs/RBAC%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E6%A6%82%E8%BF%B0.png" alt="" loading="lazy"></p><p>这也是RBAC最基础的模型，好处就是角色附带多个权限，绑定角色身份给某个用户，就相当于批量调整了一堆权限给该用户，即可以批量调整了。</p><h3 id="rbac1" tabindex="-1">RBAC1 <a class="header-anchor" href="#rbac1" aria-label="Permalink to &quot;RBAC1&quot;">​</a></h3><p>RBAC1的主要思想也非常简单，就是基于RBAC0增加了<strong>角色继承</strong>的概念。还是那句话“遇事不决，再加一层”，一层角色不够，那就多加几层角色。就好比军队中的班排连旅这样。</p><p>当然，具体加几层根据自己系统的复杂度而定。</p><p><img src="https://oss.justin3go.com/blogs/RBAC1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E6%A6%82%E8%BF%B0.png" alt="" loading="lazy"></p><h3 id="rbac2" tabindex="-1">RBAC2 <a class="header-anchor" href="#rbac2" aria-label="Permalink to &quot;RBAC2&quot;">​</a></h3><p>RBAC2的主要思想也比较简单，就是基于RBAC0增加了<strong>角色约束控制</strong>的条件，比如用户不能同时为上海的员工角色以及重庆的员工角色之类的。</p><p>主要包括了以下约束条件：</p><ul><li>互斥约束：绑定了该角色，就不能与该角色互斥的其他角色进行绑定；</li><li>基数约束： <ol><li>角色被分配的用户数量</li><li>用户可绑定的角色数量</li><li>角色对应的权限数量</li></ol></li><li>先决条件角色：即用户想获得某上级角色,必须先获得其下一级的角色</li></ul><h3 id="rbac3" tabindex="-1">RBAC3 <a class="header-anchor" href="#rbac3" aria-label="Permalink to &quot;RBAC3&quot;">​</a></h3><p>RBAC3 = RBAC1 + RBAC2，就是同时拥有角色继承以及角色约束的功能，没啥说的，反正就是根据自己的业务复杂情况自行扩展。主要思想还是主要用了解耦&quot;角色&quot;。</p><p><img src="https://oss.justin3go.com/blogs/RBAC3%E8%A1%A8%E6%83%85%E5%8C%85.png" alt="" loading="lazy"></p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><ul><li>RBAC0：增加了角色的解耦层</li><li>RBAC1：角色内再解耦，角色继承</li><li>RBAC2：角色分配增加约束条件，不能随意分配</li><li>RBAC3：结合RBAC1与RBAC2灵活使用</li></ul><h2 id="基于规则的访问控制-rubac" tabindex="-1">基于规则的访问控制（RuBAC） <a class="header-anchor" href="#基于规则的访问控制-rubac" aria-label="Permalink to &quot;基于规则的访问控制（RuBAC）&quot;">​</a></h2><h3 id="基本介绍-3" tabindex="-1">基本介绍 <a class="header-anchor" href="#基本介绍-3" aria-label="Permalink to &quot;基本介绍&quot;">​</a></h3><blockquote><p>Ru代表Rule，与RBAC中的R代表Role做区分</p></blockquote><p>安全管理员设置高级规则来确定员工如何、在何处以及何时可以访问空间或资源。管理员为<strong>每个空间或资源设置一个控制列表</strong>。当员工试图获得访问权限时，访问控制系统会检查要求列表并授予或拒绝访问权限。</p><p>基于规则的模型经常与其他模型结合使用，尤其是基于角色的模型。<strong>这种混合方法使管理员能够设置精细的规则</strong>，提供额外的安全级别以满足特定类型的风险。访问权限与特定角色无关，它可用于覆盖员工拥有的其他权限。</p><h3 id="例子-2" tabindex="-1">例子 <a class="header-anchor" href="#例子-2" aria-label="Permalink to &quot;例子&quot;">​</a></h3><ul><li>具有基于角色的权限访问保存人事记录的房间的 HR 专业人员可能无法访问该区域，如果该区域包含在周末拒绝所有员工访问的规则。</li><li>该资源维护期间拒绝任何访问。</li><li>安全系统检测到多次失败的授权尝试，拒绝用户访问。</li></ul><p><img src="https://oss.justin3go.com/blogs/RuBAC%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0.png" alt="" loading="lazy"></p><h2 id="基于属性的访问控制-abac" tabindex="-1">基于属性的访问控制（ABAC） <a class="header-anchor" href="#基于属性的访问控制-abac" aria-label="Permalink to &quot;基于属性的访问控制（ABAC）&quot;">​</a></h2><h3 id="基本介绍-4" tabindex="-1">基本介绍 <a class="header-anchor" href="#基本介绍-4" aria-label="Permalink to &quot;基本介绍&quot;">​</a></h3><p>你可以将其简单理解为更加细粒度的RBAC模型，ABAC模型通常是基于用户的属性（如身份、地点、时间等）和资源属性（如文件类型、敏感度等）进行判断的。你甚至可以把角色理解为该用户的一个属性，这些模型之间本身就不是互斥的，最终还是为了方便管理权限而来，所以灵活使用即可。</p><p>值得注意的是，ABAC模型一般是基于已有的一些属性来进行的权限划分，而RBAC模型则是在人为重新设置了几个角色来管理权限。</p><h3 id="例子-3" tabindex="-1">例子 <a class="header-anchor" href="#例子-3" aria-label="Permalink to &quot;例子&quot;">​</a></h3><ul><li>学校通知：在学校，通知的发布需要基于课程、年级或批次，让只有那些有资格看到通知的学生可以看到。</li><li>小区管理：物业管理人员可能需要基于住户身份、房屋所有权、访问时间等来管理小区门禁。</li><li>男女厕所：男生进男厕所，女生进女厕所。</li></ul><p><img src="https://oss.justin3go.com/blogs/ABAC%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0.png" alt="" loading="lazy"></p><h2 id="我的场景" tabindex="-1">我的场景 <a class="header-anchor" href="#我的场景" aria-label="Permalink to &quot;我的场景&quot;">​</a></h2><p>我的场景比较简单，并不涉及到类似于组织架构这类庞大的系统。总的来说基本需求如下，当然并不是最后的设计，只是简单举个例子：</p><ul><li>需求1：VIP用户拥有几种权限（如无限次访问该接口、无广告、可免费使用付费问卷等等）</li><li>需求2：该接口访问频率过快限制其一天的访问权限（只限制接口访问权限）</li></ul><p>显然，使用RBAC0结合RuBAC这类混合模型是最佳选择，RBAC0提供VIP角色和普通用户角色的权限区分，而RuBAC提供一些精细化的规则控制。</p><p><img src="https://oss.justin3go.com/blogs/RBACdbml.png" alt="" loading="lazy"></p><p>如上是一个简单的RBAC0的实现，非常简单，就是一个<code>用户&lt;--&gt;角色&lt;--&gt;权限</code>的多对多关系。当然RuBAC由于只有一条规则就没有单独针对接口资源与该规则建表了（真懒🤣）</p><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>本文主要讲述了几种常见的权限控制模型</p><ul><li>DAC：自主，用户自己控制自己拥有的权限资源</li><li>MAC：强制，管理员统一控制用户拥有的权限</li><li>RBAC：解耦角色，用户&lt;--&gt;角色&lt;--&gt;权限，多对多关系，便于批量管理</li><li>RuBAC：对资源增加特定规则的控制</li><li>ABAC：根据实体已有的属性进行划分权限</li></ul><p>总之，就像标题说的该加哪一个模型这种说法就是错误的，大多数场景都不是固定化的，要灵活解耦、灵活使用。</p><p>本文更多是基于别人的理解而理解，实际操作经验较少，如有理解不到位或者错误的地方，欢迎在评论区中友善讨论。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6865492774079168519" target="_blank" rel="noreferrer">权限系统基础知识笔记</a></li><li><a href="https://butterflymx.com/blog/access-control-models/" target="_blank" rel="noreferrer">The 4 Types of Access Control Models Explained [+Examples]</a></li><li><a href="https://www.cnblogs.com/iceblow/p/11121362.html" target="_blank" rel="noreferrer">权限系统设计</a></li><li><a href="https://www.openpath.com/blog-post/access-control-models" target="_blank" rel="noreferrer">Access control models: Discretionary, mandatory, role-based, and rule-based</a></li><li><a href="https://dev.to/egeaytin/rbac-vs-rebac-when-to-use-them-47c4" target="_blank" rel="noreferrer">RBAC vs ReBAC: When to use them</a></li><li><a href="https://www.cnblogs.com/iceblow/p/11121362.html" target="_blank" rel="noreferrer">可能是史上最全的权限系统设计</a></li></ul>',76))])}const D=h(E,[["render",m]]);export{x as __pageData,D as default};
