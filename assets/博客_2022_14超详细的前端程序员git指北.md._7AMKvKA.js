import{_ as d}from"./chunks/WDocTitleMeta.DRhi_zAw.js";import{_ as h,C as r,c as o,o as t,j as n,G as c,aU as g,a as k,w as b,b as m,e as u}from"./chunks/framework.BAt86-JR.js";import"./chunks/theme.CnW2W-gF.js";const j=JSON.parse('{"title":"超详细的前端程序员git指北","description":"","frontmatter":{},"headers":[],"relativePath":"博客/2022/14超详细的前端程序员git指北.md","filePath":"博客/2022/14超详细的前端程序员git指北.md","lastUpdated":1760196138000}'),F={name:"博客/2022/14超详细的前端程序员git指北.md"};function y(i,s,v,f,C,B){const l=d,p=r("ClientOnly");return t(),o("div",null,[s[0]||(s[0]=n("h1",{id:"超详细的前端程序员git指北",tabindex:"-1"},[k("超详细的前端程序员git指北 "),n("a",{class:"header-anchor",href:"#超详细的前端程序员git指北","aria-label":'Permalink to "超详细的前端程序员git指北"'},"​")],-1)),c(p,null,{default:b(()=>{var e,a;return[(((e=i.$frontmatter)==null?void 0:e.aside)??!0)&&(((a=i.$frontmatter)==null?void 0:a.showWDocTitleMeta)??!0)?(t(),m(l,{key:0,article:i.$frontmatter},null,8,["article"])):u("",!0)]}),_:1}),s[1]||(s[1]=g('<blockquote><p>git是团队开发必备工具之一，本期教程我们从一个开发人员开发新功能，然后合并到主分支上的一整个流程进行演示讲解，而不是仅仅告诉你这个命令的作用是什么，区别是什么，毕竟程序员始终得贯穿“学以致用”这条硬道理，最后再对不同的常见命令及逆行讲解。</p></blockquote><h2 id="一个git小demo" tabindex="-1">一个git小demo <a class="header-anchor" href="#一个git小demo" aria-label="Permalink to &quot;一个git小demo&quot;">​</a></h2><p>这是这个例子要演示的整体节点图，接下来的demo就是按照如下流程进行演示的</p><p><img src="https://oss.justin3go.com/blogs/git_demo%E4%BE%8B%E5%AD%90.png" alt="" loading="lazy"></p><p>注：<code>preonline =&gt; main</code> 这里没有画出来，理论上和<code>feat_login =&gt; preonline</code>一致也会进行一次<code>fast-forward merge</code></p><h3 id="step1-开始" tabindex="-1">step1：开始 <a class="header-anchor" href="#step1-开始" aria-label="Permalink to &quot;step1：开始&quot;">​</a></h3><blockquote><p>为了方便理解，这里我们不深入git的原理，它是如何追踪的，它是如何在多个分支中切换的这些都不谈，本篇文章的目的也主要是带大家真正会使用git，真正成为我们手上的工具</p></blockquote><p>首先这里我在github创建了一个仓库来演示这个过程：</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115173556.png" alt="" loading="lazy"></p><p>然后我们克隆这个仓库，当然前提是你已经安装了git并配置了基本信息：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git@github.com:Justin3go/test-git.git</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>运行效果如下：</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115191425.png" alt="" loading="lazy"></p><p>目前，这个项目只有<code>main</code>一个分支，但一般来说，一个线上项目至少都会还有一个<code>preonline</code>的分支，当然，具体到各个项目可能主要分支情况又不一样，这里介绍一种比较常见的情况，后续遇到不同的分支结构类比并参考<code>contributing.md</code>这类文档开发就应该没什么问题了。</p><p>所以我们简单创建一个基本结构，多创建一个<code>preonline</code>分支：该分支的作用就是所有其他功能分支就只能合并进入<code>preonline</code>分支，没什么问题之后才会合入<code>main</code>分支进行上线；</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> preonline</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 创建并切换分支</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115192356.png" alt="" loading="lazy"></p><h3 id="step2-开发分支" tabindex="-1">step2：开发分支 <a class="header-anchor" href="#step2-开发分支" aria-label="Permalink to &quot;step2：开发分支&quot;">​</a></h3><p>接下来我们就可以开发分支了，一般来说，看大家团队自己的规范，比如要求所有开发分支必须以<code>dev</code>作为前缀，而还有些是要求以分支具体情况作为分支名，比如<code>feat_init</code>、<code>fix_some_bug</code>、<code>style_botton</code>等等，这和我们平常的<code>commit</code>信息的前缀是一致的，而具体来说有如下的前缀：</p><ul><li><code>build</code>：表示构建，发布版本可用这个</li><li><code>ci</code>：更新 CI/CD 等自动化配置</li><li><code>chore</code>：杂项，其他更改</li><li><code>docs</code>：更新文档</li><li><code>feat</code>：常用，表示新增功能</li><li><code>fix</code>：常用：表示修复 bug</li><li><code>perf</code>：性能优化</li><li><code>refactor</code>：重构</li><li><code>revert</code>：代码回滚</li><li><code>style</code>：样式更改</li><li><code>test</code>：单元测试更改</li></ul><p>比如我们现在需要新增一个登录功能，我们就创建我们自己的分支：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 切换到主分支</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feat_login</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 创建并切换到我们自己的分支</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115194749.png" alt="" loading="lazy"></p><p>然后我们就可以进行开发了：</p><p><strong>首先我先开发完了基本上所有的功能，下面是我新增的代码，然后准备提交</strong></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115195139.png" alt="" loading="lazy"></p><p>基本来说，你可以直接使用vscode的可视化命令，也可以使用如下的<code>git</code>命令进行操作</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 暂存所有更改的文件</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115195322.png" alt="" loading="lazy"></p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;feat: 完成登录功能&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 提交并添加提交信息</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115195443.png" alt="" loading="lazy"></p><p>**然后我们点击分布分支就会在远程仓库里面创建一个一样的分支： **</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115195616.png" alt="" loading="lazy"></p><p><strong>然后走查的时候产品经理说button样式不对，所以你继续进行修改：</strong></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115195821.png" alt="" loading="lazy"></p><p><strong>然后你接着和之前一样提交代码<code>git add .</code>，<code>git commit -m &quot;style: login button color&quot;</code>，再然后就是你就需要推送到远程分支了<code>git push</code></strong></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115200121.png" alt="" loading="lazy"></p><h3 id="step3-合并多次提交" tabindex="-1">step3：合并多次提交 <a class="header-anchor" href="#step3-合并多次提交" aria-label="Permalink to &quot;step3：合并多次提交&quot;">​</a></h3><p>前面一小节的内容几乎都是在自己的分支上操作，所以都是一些比较简单的命令，接下来就是要和团队对齐了，比如一般来说为了最后主分支上的commit信息简洁和可读性，每个功能分支上面的多个commit都需要合并成一个commit，比如我们刚才的<code>feat_login</code>分支就有两个commit，所以现在我们进行合并：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rebase</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD~2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 合并最近两次提交</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><blockquote><p>这里还是先将整个流程走完，某些经典命令比如这里的<code>rebase</code>的详细使用指南可以查看后续的章节</p></blockquote><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115202023.png" alt="" loading="lazy"></p><p>然后我们修改其中的提交信息如下：</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115202308.png" alt="" loading="lazy"> 这里发现我这里的git默认使用的是nano编辑器，但我比较熟悉vim，所以设置一下git的默认编辑器：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --global</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> core.editor</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vim</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>之后修改信息为如下这个样子然后<code>esc wq</code>保存退出就可以了：</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115202858.png" alt="" loading="lazy"></p><p>再然后我们输入<code>git log --oneine</code>查看提交信息就可以发现修改成功了，如下图，之前的两次提交合并成为了一次提交：</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115203200.png" alt="" loading="lazy"></p><h3 id="step4-同步preonline分支" tabindex="-1">step4：同步preonline分支 <a class="header-anchor" href="#step4-同步preonline分支" aria-label="Permalink to &quot;step4：同步preonline分支&quot;">​</a></h3><p>在团队开发时，大家基本都并行开发，每周基本都有几个需求会在同一个项目中进行修改，不可避免的就是在提交合并请求时（github叫做<code>pull request</code> ，gitlab叫做<code>merge request</code>）这里简称为<code>MR</code>，需要同步最新的代码，如果有冲突，还需要解决冲突，之后才能提交<code>MR</code></p><p>为了演示，我直接在github上面修改了<code>preonline</code>分支上的内容如下，假设是其他人进行了开发，并在我们之前合并到了<code>preonline</code></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115214947.png" alt="" loading="lazy"></p><p>然后我们在本地先拉取最新的<code>preonline</code>分支</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115215136.png" alt="" loading="lazy"></p><p>然后我们就需要切换到自己的分支进行同步操作了</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feat_login</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rebase</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> preonline</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 同步最新的：将自己新开发的提交变基到最新的preonline分支上</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115215525.png" alt="" loading="lazy"></p><p>很好，我们遇到冲突了，我们点击在合并编辑器中打开，你也可以直接在这里操作，不过我喜欢好看一点的合并编辑器：</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115215809.png" alt="" loading="lazy"></p><p>然后就需要你手动选择要合并的代码，这里你要和别人商量一下要谁的登录页，这个例子可能不太好，现实中一般不会两个人开发同一个按钮，这里仅仅为了演示。</p><p>然后你点击<code>accept</code>其中一个，最后点接受合并就可以了</p><p>继续刚才的<code>rebase</code>操作，在此之前你可能还需要<code>git add .</code>一下</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rebase</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --continue</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>如果你在处理完冲突后不想继续当前的<code>rebase</code>操作了，比如冲突处理错了等等，你可以<code>git rebase --abort</code></p></blockquote><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115220146.png" alt="" loading="lazy"></p><p>还要记得<code>git push</code>一下，本地推送到远程，并且需要<code>-f</code>参数，因为我们修改了以前的提交的信息，注意由于这是在我们自己的分支上操作，所以<code>-f</code>是可行的。</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115220451.png" alt="" loading="lazy"></p><p>之后我们在github上面操作，去提交<code>MR</code></p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115220619.png" alt="" loading="lazy"></p><p>然后项目的负责人或者核心成员就可以对你的代码进行<code>CR</code>了（<code>code review</code>）</p><p><img src="https://oss.justin3go.com/blogs/Pasted%20image%2020221115220742.png" alt="" loading="lazy"></p><p><code>CR</code>完成之后，就是项目负责人同意合并请求，你的代码就成功合并到了<code>preonline</code>，不同项目有不同的周期，等到上线当天，<code>preonline</code>里面的代码就会被项目负责人合并到<code>main</code>分支上完成上线。</p><h2 id="git-log介绍" tabindex="-1"><code>git log</code>介绍 <a class="header-anchor" href="#git-log介绍" aria-label="Permalink to &quot;`git log`介绍&quot;">​</a></h2><p>查看提交信息，一般会用<code>git log --oneline</code>简略查看之前的提交；</p><p><a href="https://git-scm.com/docs/git-log" target="_blank" rel="noreferrer">官网快速入口</a></p><p><a href="https://www.jianshu.com/p/0805b5d5d893" target="_blank" rel="noreferrer">git log 的使用</a></p><h2 id="撤回提交之reset与revert" tabindex="-1">撤回提交之<code>reset</code>与<code>revert</code> <a class="header-anchor" href="#撤回提交之reset与revert" aria-label="Permalink to &quot;撤回提交之`reset`与`revert`&quot;">​</a></h2><p>开发中频繁使用 git 拉取推送代码，难免会有误操作。这个时候不要慌，git 支持绝大多数场景的撤回方案，我们来总结一下。</p><p>撤回主要是两个命令：<code>reset</code> 和 <code>revert</code></p><h4 id="git-reset" tabindex="-1">git reset <a class="header-anchor" href="#git-reset" aria-label="Permalink to &quot;git reset&quot;">​</a></h4><p>reset 命令的原理是根据 <code>commitId</code> 来恢复版本。因为每次提交都会生成一个 commitId，所以说 reset 可以帮你恢复到历史的任何一个版本。</p><blockquote><p>这里的版本和提交是一个意思，一个 commitId 就是一个版本</p></blockquote><p>reset 命令格式如下：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [option] [commitId]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>比如，要撤回到某一次提交，命令是这样：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --hard</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cc7b5be</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的命令，commitId 是如何获取的？通过之前介绍的<code>git log</code>命令即可查看</p><p>这里的 option 用的是 <code>--hard</code>，其实共有 3 个值，具体含义如下：</p><ul><li><code>--hard</code>：撤销 commit，撤销 add，删除工作区改动代码</li><li><code>--mixed</code>：默认参数。撤销 commit，撤销 add，还原工作区改动代码</li><li><code>--soft</code>：撤销 commit，不撤销 add，还原工作区改动代码</li></ul><p>除了使用 commitId 恢复，git reset 还提供了恢复到上一次提交的快捷方式：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --soft</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD^</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>HEAD^</code> 表示上一个提交，可多次使用。</p><p>其实平日开发中最多的误操作是这样：刚刚提交完，突然发现了问题，比如提交信息没写好，或者代码更改有遗漏，这时需要撤回到上次提交，修改代码，然后重新提交。</p><p>这个流程大致是这样的：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1. 回退到上次提交</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD^</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 2. 修改代码...</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 3. 加入暂存</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 4. 重新提交</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;fix: ***&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>针对这个流程，git 还提供了一个更便捷的方法：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --amend</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个命令会直接修改当前的提交信息。如果代码有更改，先执行 <code>git add</code>，然后再执行这个命令，比上述的流程更快捷更方便。</p><p>reset 还有一个非常重要的特性，就是<strong>真正的后退一个版本</strong>。</p><p>什么意思呢？比如说当前提交，你已经推送到了远程仓库；现在你用 reset 撤回了一次提交，此时本地 git 仓库要落后于远程仓库一个版本。此时你再 push，远程仓库会拒绝，要求你先 pull。</p><p>如果你需要远程仓库也后退版本，就需要 <code>-f</code> 参数，强制推送，这时本地代码会覆盖远程代码。</p><h4 id="git-revert" tabindex="-1">git revert <a class="header-anchor" href="#git-revert" aria-label="Permalink to &quot;git revert&quot;">​</a></h4><p>revert 与 reset 的作用一样，都是恢复版本，但是它们两的实现方式不同。</p><p>简单来说，reset 直接恢复到上一个提交，工作区代码自然也是上一个提交的代码；而 revert 是新增一个提交，但是这个提交是使用上一个提交的代码。</p><p>因此，它们两恢复后的代码是一致的，区别是一个新增提交（revert），一个回退提交（reset）。</p><p>正因为 revert 永远是在新增提交，因此本地仓库版本永远不可能落后于远程仓库，可以直接推送到远程仓库，故而解决了 reset 后推送需要加 <code>-f</code> 参数的问题，提高了安全性。</p><p>说完了原理，我们再看一下使用方法：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> revert</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [commitId]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="git-rebase介绍" tabindex="-1"><code>git rebase</code>介绍 <a class="header-anchor" href="#git-rebase介绍" aria-label="Permalink to &quot;`git rebase`介绍&quot;">​</a></h2><p><a href="https://git-scm.com/docs/git-rebase" target="_blank" rel="noreferrer">官网快速入口</a></p><p>常见操作：</p><ul><li><code>git rebase -i head~2</code>：合并最近两次提交</li><li><code>git rebase -i head~3</code>：合并最近三次提交</li><li><code>git rebase -i [commitId]</code>：合并<code>[commitId]</code>之前的所有提交，不包括<code>[commitId]</code>对应的提交</li><li><code>git rebase master</code>：同步到主分支：将我在功能分支新的提交尝试提交到最新的<code>master</code>分支上</li></ul><p>基本原理：</p><p><img src="https://oss.justin3go.com/blogs/rebase%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="" loading="lazy"></p><p>如上图：</p><ul><li>我在<code>历史提交3</code>部分创建了功能分支并开发新增了两个提交</li><li>其他人在主分支上提交了新的代码<code>更新提交1</code>与<code>更新提交2</code></li><li>我们本地拉取最新的<code>master</code>分支</li><li>然后我们在我们自己的功能分支上<code>git rebase master</code> 就可以得到图中下半部分</li></ul><p><a href="https://juejin.cn/post/6844903600976576519" target="_blank" rel="noreferrer">逐步操作演示可参考</a></p><h2 id="git-merge介绍" tabindex="-1"><code>git merge</code>介绍 <a class="header-anchor" href="#git-merge介绍" aria-label="Permalink to &quot;`git merge`介绍&quot;">​</a></h2><p>将两个或多个开发历史合并在一起</p><p><a href="https://git-scm.com/docs/git-merge" target="_blank" rel="noreferrer">官网入口</a></p><p>基本原理：</p><p><img src="https://oss.justin3go.com/blogs/merge%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="" loading="lazy"></p><p><code>merge</code>会将功能提交和更新提交合并并创建一个新的提交，会有更丰富的提交信息。当然，这个“丰富”在某些情况又可以称为“杂乱”，具体用什么看大家自己的团队规范了。</p><h2 id="git-cherry-pick介绍" tabindex="-1"><code>git cherry-pick</code>介绍 <a class="header-anchor" href="#git-cherry-pick介绍" aria-label="Permalink to &quot;`git cherry-pick`介绍&quot;">​</a></h2><p>这个命令非常好用并且简单，它的功能是把已经存在的commit进行挑选，然后重新提交</p><p>例子：</p><p>在<code>master</code>的基础上，<code>test</code>进行了2次提交，<code>normal</code>进行了1次提交。现在想把<code>test</code>的第2次提交 （仅仅是第2次提交，不包含第1次提交）和<code>normal</code>的第1次提交合并到master分支，直接merge分支是行不通的，这样会把两个分支的全部提交都合并到<code>master</code>，用<code>cherry-pick</code>即可完美的解决问题， 如果<code>normal</code>第一次提交的<code>SHA-1</code>值是<code>9b47dd</code>，<code>test</code>第二次提交的值是<code>dd4e49</code>，执行如下命令即可把这两个提交合并到<code>master</code></p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cherry-pick</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 9b47dd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dd4e49</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果有冲突，则需要修改冲突文件，然后添加修改文件到暂存区，命令如下：</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>最后执行</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cherry-pick</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --continue</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>cherry-pick后</p><p>最后要说明的是：</p><ul><li>执行完<code>git cherry-pick --continue</code>后不需要commit了，该命令会自动提交</li><li><code>git cherry-pick --abort</code>可以放弃本次<code>cherry-pick</code></li><li><code>git cherry-pick 9b47dd dd4e49</code>和<code>git cherry-pick dd4e49 9b47dd</code>这两个的结果可能会<strong>不一样</strong>，<strong>顺序很重要</strong></li></ul><h2 id="其他快捷操作" tabindex="-1">其他快捷操作 <a class="header-anchor" href="#其他快捷操作" aria-label="Permalink to &quot;其他快捷操作&quot;">​</a></h2><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D" target="_blank" rel="noreferrer">通过<code>git alias</code>简化命令</a></p><p><a href="https://github.com/commitizen/cz-conventional-changelog" target="_blank" rel="noreferrer">https://github.com/commitizen/cz-conventional-changelog</a></p><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>本篇文章对原理并没有研究，仅仅演示了使用，并且对一些细节部分也没有一一演示验证，如有理解错误，欢迎友善指出🎉</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://git-scm.com/docs" target="_blank" rel="noreferrer">https://git-scm.com/docs</a></li><li><a href="https://juejin.cn/post/7024043015794589727" target="_blank" rel="noreferrer">https://juejin.cn/post/7024043015794589727</a></li><li><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_5.html" target="_blank" rel="noreferrer">https://backlog.com/git-tutorial/cn/stepup/stepup1_5.html</a></li><li><a href="https://juejin.cn/post/7064134612129644558" target="_blank" rel="noreferrer">https://juejin.cn/post/7064134612129644558</a></li><li><a href="https://juejin.cn/post/6844903521993621511" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903521993621511</a></li><li><a href="https://juejin.cn/post/6844903600976576519" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903600976576519</a></li></ul>',145))])}const x=h(F,[["render",y]]);export{j as __pageData,x as default};
