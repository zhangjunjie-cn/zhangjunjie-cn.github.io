import{_ as d}from"./chunks/WDocTitleMeta.DGR9uaji.js";import{_ as p,C as c,c as h,o as t,j as l,G as r,aU as k,a as E,w as u,b as g,e as m}from"./chunks/framework.B1VJwv5O.js";import"./chunks/theme.DIgpgW51.js";const x=JSON.parse('{"title":"Node异步实现与事件驱动","description":"","frontmatter":{},"headers":[],"relativePath":"博客/2022/10Node异步实现与事件驱动.md","filePath":"博客/2022/10Node异步实现与事件驱动.md","lastUpdated":1760196138000}'),b={name:"博客/2022/10Node异步实现与事件驱动.md"};function y(e,s,I,q,O,F){const n=d,o=c("ClientOnly");return t(),h("div",null,[s[0]||(s[0]=l("h1",{id:"node异步实现与事件驱动",tabindex:"-1"},[E("Node异步实现与事件驱动 "),l("a",{class:"header-anchor",href:"#node异步实现与事件驱动","aria-label":'Permalink to "Node异步实现与事件驱动"'},"​")],-1)),r(o,null,{default:u(()=>{var i,a;return[(((i=e.$frontmatter)==null?void 0:i.aside)??!0)&&(((a=e.$frontmatter)==null?void 0:a.showWDocTitleMeta)??!0)?(t(),g(n,{key:0,article:e.$frontmatter},null,8,["article"])):m("",!0)]}),_:1}),s[1]||(s[1]=k(`<blockquote><p>这是重新阅读《深入浅出NodeJS》的相关笔记，这次阅读发现自己依旧收获很多，而第一次阅读的东西也差不多忘记完了，所以想着这次过一遍脑子，用自己的理解输出一下，方便记忆以及以后回忆...</p></blockquote><h2 id="node的特点" tabindex="-1">Node的特点 <a class="header-anchor" href="#node的特点" aria-label="Permalink to &quot;Node的特点&quot;">​</a></h2><blockquote><p>计算机中的一些任务一般可以划分为两个类别，一个类别叫做IO密集型，一个叫做计算密集型；对于计算密集型的任务，只能不断榨干CPU的性能，但是对于IO密集型的任务来说，理想情况下却并不需要，只需要通知IO设备进行处理，过一段时间再来拿去数据就好了。</p></blockquote><p>对于某些场景有一些互不相关的任务需要完成，现行的主流方法有如下两种：</p><ul><li>多线程并行完成：多线程的代价在于创建线程和执行线程上下文切换的开销较大。另外，在复杂的业务中，多线程编程经常面临锁、状态同步等问题；</li><li>单线程顺序执行：易于表达，但串行执行的缺点在于性能，任意一个略慢的任务都会导致后续代码被组设</li></ul><p><code>node</code>在两者之前给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步IO，让单线程远离阻塞，以更好地使用CPU</p><p><img src="https://oss.justin3go.com/blogs/%E5%BC%82%E6%AD%A5IO%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="" loading="lazy"></p><h2 id="node是如何实现异步的" tabindex="-1">Node是如何实现异步的 <a class="header-anchor" href="#node是如何实现异步的" aria-label="Permalink to &quot;Node是如何实现异步的&quot;">​</a></h2><blockquote><p>刚才讲了<code>node</code>在多任务处理的方案，但是<code>node</code>内部想要实现却并不容易，下面介绍操作系统的几个概念，方面后续大家更好理解，后面再讲一讲异步的实现以及node的事件循环机制：</p></blockquote><h3 id="阻塞io与非阻塞io" tabindex="-1">阻塞IO与非阻塞IO <a class="header-anchor" href="#阻塞io与非阻塞io" aria-label="Permalink to &quot;阻塞IO与非阻塞IO&quot;">​</a></h3><ul><li>阻塞IO：应用层面发起IO调用之后，就一直等待数据，等操作系统内核层面完成所有操作后，调用才结束；</li></ul><blockquote><p>操作系统中一切皆文件，输入输出设备同样被抽象为了文件，内核在执行IO操作时，通过<strong>文件描述符</strong>进行管理</p></blockquote><ul><li>非阻塞IO：差别为调用后立即返回一个文件描述符，并不等待，这时候CPU的时间片就可以用来处理其他事务，之后可以通过这个文件描述符进行结果的获取；</li></ul><p>非阻塞IO存在的一些问题：虽然其让CPU的利用率提高了，但是由于立即返回的是一个文件描述符，我们并不知道IO操作什么时候完成，为了确认状态变更，我们只能作轮询操作</p><h3 id="不同的轮询方法" tabindex="-1">不同的轮询方法 <a class="header-anchor" href="#不同的轮询方法" aria-label="Permalink to &quot;不同的轮询方法&quot;">​</a></h3><ul><li><code>read</code> ：最原始、性能最低的一种，通过<strong>重复检查IO状态</strong>来完成完整数据的获取</li><li><code>select</code>：通过对<strong>文件描述符上的事件状态</strong>来进行判断，相对来说消耗更少；缺点就是它采用了一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符</li><li><code>poll</code>：由于<code>select</code>的限制，<code>poll</code>改进为链表的存储方式，其他的基本都一致；但是当文件描述符较多的时候，它的性能还是非常低下的</li><li><code>eopll</code>：该方案是<code>linux</code>下效率最高的IO事件通知机制，在进入轮询的时候如果没有检查IO事件，将会进行休眠，直到事件发生将它唤醒</li><li><code>kqueue</code>：与<code>epoll</code>类似，不过仅在FreeBSD系统下存在</li></ul><p>尽管<code>epoll</code>利用了事件来降低对CPU的耗用，但休眠期间CPU几乎是闲置的；我们期待的异步IO应该是应用程序发起非阻塞调用，无须通过遍历或事件唤醒等方式轮询，可以直接处理下一个任务，只需IO完成后通过信号或者回调将数据传递给应用程序即可。</p><blockquote><p>linux下还有中AIO方式就是通过信号或回调来传递数据的，不过只有Linux有，并且有限制无法利用系统缓存</p></blockquote><h3 id="node中对于异步io的实现" tabindex="-1">node中对于异步IO的实现 <a class="header-anchor" href="#node中对于异步io的实现" aria-label="Permalink to &quot;node中对于异步IO的实现&quot;">​</a></h3><p>先说结论，<code>node</code>对异步IO的实现是通过多线程实现的。可能会混淆的地方就是<code>node</code>内部虽然是多线程的，但是我们程序员开发的<code>JavaScript</code>代码却仅仅是运行在单线程上的。</p><p><code>node</code>通过部分线程进行阻塞IO或者非阻塞IO加上轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将IO得到的数据进行传递，这就轻松实现了异步IO的模拟。</p><p><img src="https://oss.justin3go.com/blogs/node%E5%BC%82%E6%AD%A5IO.png" alt="" loading="lazy"></p><p>除了异步IO，计算机中的其他资源也适用，因为linux中一切皆文件，磁盘、硬件、套接字等几乎所有计算机资源都被抽象为了文件，接下来介绍对计算机资源的调用都以IO为例子。</p><h3 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h3><p>在进程启动时，<code>node</code>便会创建一个类似与<code>while(true)</code>的循环，每执行一次循环体的过程我们成为<code>Tick</code>；</p><p>下方为<code>node</code>中事件循环流程图：</p><p><img src="https://oss.justin3go.com/blogs/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="" loading="lazy"></p><p>很简单的一张图，简单解释一下：就是每次都从IO观察者里面获取执行完成的事件（是个请求对象，简单理解就是包含了请求中产生的一些数据），然后没有回调函数的话就继续取出下一个事件（请求对象），有回调就执行回调函数</p><h2 id="异步io细节" tabindex="-1">异步IO细节 <a class="header-anchor" href="#异步io细节" aria-label="Permalink to &quot;异步IO细节&quot;">​</a></h2><p><img src="https://oss.justin3go.com/blogs/%E6%95%B4%E4%B8%AA%E5%BC%82%E6%AD%A5IO%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="" loading="lazy"></p><blockquote><p>注：不同平台有不同的细节实现，这张图隐藏了相关平台兼容细节，比如windows下使用IOCP中的<code>PostQueuedCompletionStatus()</code>提交执行状态，通过<code>GetQueuedCompletionStatus</code>获取执行完成的请求，并且IOCP内部实现了线程池的细节，而linux等平台通过<code>eopll</code>实现这个过程，并在<code>libuv</code>下自实现了线程池</p></blockquote><h2 id="settimtout与setinterval" tabindex="-1"><code>setTimtout</code>与<code>setInterval</code> <a class="header-anchor" href="#settimtout与setinterval" aria-label="Permalink to &quot;\`setTimtout\`与\`setInterval\`&quot;">​</a></h2><p>除了IO等计算机资源需要异步调用之外，<code>node</code>本身还存在一些与异步IO无关的一些<strong>其他异步API</strong>：</p><ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>process.nextTick</code></li></ul><blockquote><p>该小节先讲解前面两个api</p></blockquote><p>它们的实现原理与异步IO比较类似，<strong>只是不需要IO线程池的参与</strong>：</p><ul><li><code>setTimtout</code>与<code>setInterval</code>创建的定时器会被插入到定时器观察者内部的一个红黑树中</li><li>每次<code>tick</code>执行的时候，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间</li><li>如果超过，就将这个事件（请求对象）推入到事件队列中，在事件循环中执行其中的回调函数</li></ul><blockquote><p>红黑树：这里简单提一下，就是一种特殊化的平衡二叉树，可以自平衡，查找效率基本上就是该二叉树的深度了$O(log_2n)$</p></blockquote><p>你有考虑过这个问题吗，为什么定时器不需要线程池的参与了呢，如果你理解了之前章节对于异步IO实现原理的话，相信你应该能解释出来，这里简单说说原因来加深记忆：</p><p><strong><code>node</code>中的IO线程池是用来调用IO并等待数据返回（看具体实现）的一种方式，它使<code>JavaScript</code>单线程得以异步调用IO，并且不需要等待IO执行完成（因为是IO线程池做了），并且能获取到最终的数据（通过观察者模式：IO观察者从线程池获取执行完成的事件，事件循环机制执行后续的回调函数）</strong></p><p>上述这段话可能有点简略，如果你还不明白，可以看下之前的那几种图~</p><h2 id="process-nexttick与setimmediate" tabindex="-1"><code>process.nextTick</code>与<code>setImmediate</code> <a class="header-anchor" href="#process-nexttick与setimmediate" aria-label="Permalink to &quot;\`process.nextTick\`与\`setImmediate\`&quot;">​</a></h2><p>这两个函数都是代表立即异步执行一个函数，那为什么不用<code>setTimeout(() =&gt; { ... }, 0)</code>来完成呢？</p><ul><li>定时器精度不够</li><li>定时器使用红黑树来创建定时器对象和迭代操作，浪费性能</li><li>即<code>process.nextTick</code>更加轻量</li></ul><p>轻量具体来说：我们在每次调用<code>process.nextTick</code>的时候，只会将回调函数放入队列中，在下一轮<code>Tick</code>时取出执行。定时器中采用红黑树的方式时$O(log_2n)$，<code>nextTick</code>为$O(1)$</p><p>那<code>process.nextTick</code>与<code>setImmediate</code>又有什么区别呢？毕竟它们都是将回调函数立即异步执行</p><ul><li><code>process.nextTick</code>的回调执行优先级高于<code>setImmediate</code></li><li><code>process.nextTick</code>的回调函数保存在一个数组中，每轮事件循环下全部执行，<code>setImmediate</code>的结果则是保存在链表中，每轮循环按序执行第一个回调</li></ul><p>注意：之所以<code>process.nextTick</code>的回调执行优先级高于<code>setImmediate</code>，因为事件循环对观察者的检查是有顺序的，<code>process.nextTick</code>属于<code>idle</code>观察者，<code>setImmediate</code>属于<code>check</code>观察者。<code>iedl观察者 &gt; IO 观察者 &gt; check观察者</code></p><h2 id="高性能服务器" tabindex="-1">高性能服务器 <a class="header-anchor" href="#高性能服务器" aria-label="Permalink to &quot;高性能服务器&quot;">​</a></h2><blockquote><p>对于网络套接字的处理，<code>node</code>也应用到了异步IO，网络套接字上侦听到的请求都会形成事件交给IO观察者，事件循环会不停地处理这些网络IO事件，如果我们在<code>JavaScrpt</code>层面上有传入对应的回调函数，这些回调函数就会在事件循环中执行（处理这些网络请求）</p></blockquote><p>常见的服务器模型：</p><ul><li>同步式</li><li>每进程--&gt;每请求</li><li>每线程--&gt;每请求</li></ul><p>而<code>node</code>采用的是事件驱动的方式处理这些请求，无需对每个请求创建额外的对应线程，可以省略掉创建线程和销毁线程的开销，同时操作系统的调度任务因为线程较少（只有<code>node</code>内部实现的一些线程）上下文切换的代价很低。</p><p>经典问题--<strong>雪崩问题</strong>的解决：</p><p>问题描述：服务器在刚启动时，缓存无数据，如果访问量巨大，同一条<code>SQL</code>会被发送到数据库中反复查询，影响性能。</p><p>解决方案：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="复制代码" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> events.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EventEmitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ready&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态锁，避免反复查询</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;selected&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定一个只执行一次名为selected的事件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ready&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;pending&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// sql</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		db.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SQL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;selected&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, res); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 触发事件,返回查询数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ready&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>使用<code>once</code>将所有请求的回调都压入了事件队列中，利用其只执行一次就会将监视器移除的特点，保证每一个回调函数只会被执行一次。对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。新到来的相同调用只需在队列中等待数据就绪即可，一旦查询到结果，得到的结果就可以被这些调用共同使用。</p><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>基本都是参考《深入浅出NodeJS》这本书的并夹带了一些自己的理解，如果我理解有误的话，欢迎友善指出🎉</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>《深入浅出NodeJS》</li></ul>`,62))])}const C=p(b,[["render",y]]);export{x as __pageData,C as default};
